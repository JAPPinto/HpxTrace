provider com templated counter

tlc::nome do componente :: ação???


dtrace gera os contadores para os componentes no script
contadores lidam com o facto de componentes ainda não existirem

______________________________________________________________-

dtrace e contadores

probes acionadas quando contadores são lidos?
probes acionadas quando contadores chegam a certo valor
probe recebe output do contador


probe profile, dispara de n em n
	de cada vez que dispara pode obter informacao dos contadores???
	e filtrar nos predicados
		dispara de cada vez,
		dispara de x em x aumento



APEX_SAMPLE_VALUE

de cada vez que o contador é lido ocorre un evento que aciona a probe
nos predicados definir
	em que valor dispara
	a que intervalo de valores dispara: +10,-10


/value += x/
/value -= x/
/value *= x/
/value = [10, 20, 50]/

counters::counter_name::time                 
/value == x/
{
	print(value);
}



counter_name -> nome completo do contador a gerar
time -> tempo entre leituras do contador
probe tem acesso ao nome e pedaços do nome e ao valoro

Olá professor. Em relação ao uso de contadores na minha API tenho desenvolvido probes com o formato  

counters::counter_name::time                 
/value == x/
{
	print(value);
} 

No countar_name posso colocar o nome de qualquer contador, tal como nas opções de linha de comandos do HPX (excepto nomes com wildcards mas vou tentar implementar isso, assim justifica o estudo daquelas funções de descoberta e criação de contadores). O time é o período entre leituras do contador. A probe dispara a cada leitura e nela é possível usar o valor do contador. Também pretendo adicionar predicados para que as probes apenas disparem para determinados valores do contador.

Em relação a juntar a API com aquele contador que monitoriza um componente (último capítulo que enviei), em princípio esta probe funciona com esse contador mas não tenho nenhuma ideia para uma probe específica para esse contador.
Se conseguir acabar rapidamente o que estou a fazer agora vou pensar melhor nisso. Caso contrário vou focar-me em acabar de escrever o resto dos capítulos. Ainda existem algumas coisas que quero adicionar.

Também queria marcar mais uma reunião. Talvez na segunda ou na terça, acho que até lá já terei mais assuntos para discutir.









counter_value 

	replace with counter_name_counter_value
	no parse, quando vai buscar o valor de uma variavel, verifica se é counter_value. Se sim vai fazer vars[counter_name] ou recebe value como argumento


THREAD SAFE

PREDICATE
	
	/expr/
	/ a op b/



	operadores:
		c -> comparação
		! -> negação
		eou -> && e ||
		()


		( a)


print de doubles 


./probes --script 'BEGIN{r=0;}counter::/threads{locality#0/total}/count/cumulative::1000000/counter_value > r/{print(counter_name);print(counter_value);r = r + 1000;}'


wildcards

@mapas

apex metrics samples...

placor

modulo separado


counter-create(nome,t)//{	} - vantagem. controla os prints
vs
counter::nome::
	t não
	nome?

nome - cuidado com a expansão dos contadores pelo terminal, totals e *


path elements


ficheiros

/threads{locality#0/total}/count/cumulative

./probes --script 'counter::/threads{locality#0/total}/count/cumulative::{print(counter_value);}' --hpx:print-counter=/threads{locality#0/total}/count/cumulative --hpx:print-counter-interval=200

startup


apex get profile -> the_profiler_listener


timestamps para user probes 



apex.cpp

  sample_value_event_data data(tid, name, value, threaded);
    if (_notify_listeners) {
        //read_lock_type l(instance->listener_mutex);
        for (unsigned int i = 0 ; i < instance->listeners.size() ; i++) {
            instance->listeners[i]->on_sample_value(data);
        }
    }

    std::shared_ptr<task_wrapper> tt_ptr(nullptr);
    profiler * new_profiler = nullptr;
    if (_notify_listeners) {
        bool success = true;
        task_identifier * id = task_identifier::get_task_id(timer_name);
        tt_ptr = _new_task(id, UINTMAX_MAX, null_task_wrapper, instance);
        APEX_UTIL_REF_COUNT_TASK_WRAPPER
        //read_lock_type l(instance->listener_mutex);
        /*
        std::stringstream dbg;
        dbg << thread_instance::get_id() << " Start : " << id->get_name() << endl;
            printf("%s\n",dbg.str().c_str());
        fflush(stdout);
        */
        for (unsigned int i = 0 ; i < instance->listeners.size() ; i++) {
            success = instance->listeners[i]->on_start(tt_ptr);
            tt_ptr->prof = thread_instance::instance().get_current_profiler();
            if (!success && i == 0) {
                //cout << thread_instance::get_id() << " *** Not success! " <<
                //id->get_name() << endl; fflush(stdout);
                APEX_UTIL_REF_COUNT_FAILED_START
                return profiler::get_disabled_profiler();
            }
        }
como a informação é processada assincronamente, é dificl usar itso na api


adicionar numeros nas vars 


alternativas probes
    1 descrição implementação
        desc-listar pobres e sintaxe
        impl- os detalhes das probes existentes foram-se formando ao longo da implementação, esta parte segue essa narrativa
    2 na mesma secção


APEX_SAMPLE_VALUECPU User % 11.8235
APEX_SAMPLE_VALUECPU User % 11.8235
APEX_SAMPLE_VALUECPU Nice % 0
APEX_SAMPLE_VALUECPU System % 0.0832639
APEX_SAMPLE_VALUECPU Idle % 88.0933
APEX_SAMPLE_VALUECPU I/O Wait % 0
APEX_SAMPLE_VALUECPU IRQ % 0
APEX_SAMPLE_VALUECPU soft IRQ % 0
APEX_SAMPLE_VALUECPU Steal % 0
APEX_SAMPLE_VALUECPU Guest % 0
APEX_SAMPLE_VALUEPackage-0 Energy 0
APEX_SAMPLE_VALUEDRAM Energy 0




apex.cpp

        std::shared_ptr<task_wrapper> tt_ptr(nullptr);

        for (unsigned int i = 0 ; i < instance->listeners.size() ; i++) {
            success = instance->listeners[i]->on_start(tt_ptr);

açoes do parser com dados invocam acoes do componente com os dados
é mais eficiente do que o parser estar dentro do componente
melhor do que estar a lidar com varias estruturas de dados separadas.

variaveis locais à localidade ou à probe


26/Março

_probe - so adicionar no parser _ 
var - script_data em cada localidade - local_script_data

#global - variaveis em componente global

agregaçoes - são locais e no final juntam-se 


separar script data em vários componentes para os locks serem mais eficientes 

thread safety:
    doubles e strings, cada mapa está num componente
    agregações, 

race conditions:
    x = x + 1;
    outra sonda noutra localidade altera x

    proble_vars não têm race conditions 

    locality_vars têm
        implementar locks
        lock(a);
        unlock(a);
        lock mutexes
        criar mutexes na validação?
        mapa de mutexes?
        e locks nos predicados?

    
    global_vars têm
        locks é dificil 
        solucão, usar vars diferentes(e mapas) e no END juntar tudo 


    templated script data

    usar so servers, instanciar servers, passar os ids às localidades e invocar diretamente as açoes


    adicionar mapas - componente template U,T


    get do componente retorna optional - get no parse retorna bool se existe 
        _pass = get(,&x,)  _val = x

    
    atualizar predicate


    mapas - juntar nome ao array das chaves
    

    aggs- locais e global
        a global junta-se no fim
        cada agg é um componente
        fire and forget

    dividir em locais e globais?
        locality pode ser usada na chave
        utilizador pode controlar no final se quer juntar ou não

    componente com todas as agregações ou um componente por agregação
    como guardar os ids? validate retorna lista com ids? cada probe ia ficar com componentes?

    componente em cada localidade com as agregações,
    no final o utilizador decide se quer imprimir as locais ou junta-las
    script data com vetor de ids
    como lidar com concorrencia?
        tirar locking_hook
        instanciar não precisa porque é feito sequencialmente
        adicionar precisa
        scoped mutex em cada 

    validate predicate regista as aggs em todos os servidores, usar desculpa de não ser possivel
    saber onde user probes vão disparar, etc, facilita o join

    valide tudo antes de processar o script

    prints para aggs, print, global_print


    validar como antes e o componente de agregação verifica se a ag existe


    global aggregate pode receber uma lista de localidades 



     mpirun -np 2 ./probes --script 'BEGIN[0,1]{&x[0] = 5;}abc{@time[0] = sum(a);}abc{global_print(@time);print(&x[9]);}
     mudar logica dos mapas
        componente com mapa de mapas
        string,K,V?

    mpirun -np 2 ./probes --script 'BEGIN[0]{x = 3;x = "a";print(x);}'  
    imprime 3 e não pode 
    componente com variaveis double e string, e no store verifica se existe nos outros tipos
    exemplo do mapa com templates vai para o capitulo sobre componentes

    foi considerado fazer componentes templated de forma a serem reutilizaveis e a facilitar a expansão para novos tipos
    e para ser mais eficiente, acessos paralelos a doubles e strings
    no entanto isto exigiria comunicação extra na atribuição para verificar se a variavel já existia para outro tipo o que não vale a pena


    componente com mapa de mapas 
    double e string maps
    mapa existe mas chave não - retornar default ou vazio?
    mapa uniforme ou heterogeneo?
    reaproveitar scalar vars? não, todos do mesmo tipo


    timestamp
    relativa ou absoluta
    diferente em cada localidade 

    todas as probes, nome[locs]....
    regex -> nome, locs, args, predicate, actions

    

    begin[loc]
    end[loc]
    user[loc]
    
    proc[loc]::name?::
    proc[]::CPU User %::{print(locality);print(proc_value);}

    counter-create::name::time::
    mpirun -np 2 ./probes --script 'counter-create::/threads{locality#0/total/total}/count/cumulative::1000::{print(counter_name);}'

    counter-type::name::
    mpirun -np 2 ./probes --script 'counter-type::/threads/count/cumulative::{print(counter_name);}'  --hpx:print-counter=/threads{locality#*/total}/count/cumulative --hpx:print-counter-interval=200




    counter::name?::
    mpirun -np 2 ./probes --script 'counter::/threads{locality#1/total/total}/count/cumulative::{print(counter_value);}'  --hpx:print-counter=/threads{locality#*/total}/count/cumulative --hpx:print-counter-interval=200


    mpirun -np 2 ./probes --script 'counter-create::/threads{locality#0/total/total}/count/cumulative::200::{print(counter_value);}'


    task[loc]::[start,stop,yield,resume]::name?
    mpirun -np 2 ./probes --script 'task[]::[start,stop,yield,resume]::test_action::{print(locality + " " +  event + " " +  guid);}'

    message[loc]::[send,receive]?::
    mpirun -np 2 ./probes --script 'message[0,1]::[send,receive]::{print(tag);}'

    counter probe não apanha algumas leitura no inicio e no fim